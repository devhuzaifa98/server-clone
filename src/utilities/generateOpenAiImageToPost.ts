import { Post, User } from "@prisma/client";
import { fromBuffer } from "file-type";
import { v4 as uuid } from "uuid";
import { openai } from "../clients/openai";
import prisma from "../clients/prisma";
import { uploadMedia } from "../clients/s3";
import AppError from "./AppError";

const openaiError = async (post: Post, bot: any, req: any) => {
  await prisma.error.create({
    data: {
      ip: req.ip,
      userId: post.userId,
      description: "OpenAiImage creation failed",
    },
  });
  //Create post when OpenAI throws an error.
  return await prisma.post.create({
    data: {
      parentPostId: post.id,
      userId: bot.id,
      content:
        "OpenAI has experienced an error. Admin have been reported and you have not been charged.",
    },
  });
};
const generateOpenAiImageToPost = async (
  user: User, //user to be charged
  post: Post, //user post to reply to
  model: any, //model to be used
  req: any,
) => {
  try {
    //TODO let user choose bot
    const bot = await prisma.user.findFirst({
      where: {
        username: "openai",
      },
      select: {
        id: true,
        botSettings: {
          select: {
            types: true,
          },
        },
      },
    });
    if (!bot) {
      throw Error("Invalid Bot");
    }

    //Do checks first
    const requestRateLimit = await prisma.siteSettings.findMany({
      orderBy: {
        createdAt: "desc",
      },
      select: {
        requestRateLimit: true,
      },
      take: 1,
    });
    if (Number(model.cost) > user.tronsBalance) {
      await prisma.error.create({
        data: {
          ip: req.ip,
          userId: user.id,
          description:
            "RAN OUT OF TRONS FRONT END FAILED model.cost:" +
            Number(model.cost) +
            ", user.tronsBalance: " +
            user.tronsBalance,
        },
      });
      throw new AppError(
        "You have ran out of trons. You can earn more by receiving or buying tokens.",
      );
    }
    const count = await prisma.post.count({
      where: {
        userId: bot.id,
        createdAt: {
          gt: new Date(new Date().getTime() - 300000).toISOString(),
        },
        parentPost: {
          userId: user.id,
        },
      },
    });
    if (count > requestRateLimit[0].requestRateLimit) {
      await prisma.error.create({
        data: {
          ip: req.ip,
          userId: user.id,
          description: "Too many OpenAiImage Requests",
        },
      });
      throw new AppError(
        "You have made a lot of requests recently. Please take a break.",
      );
    }

    //Everything passed so make request to OpenAI
    let response: any;
    try {
      response = await openai.images.generate({
        prompt: post.content, //Make this have all the parent posts as well.
        n: 1,
        size: model.query as any,
        response_format: "b64_json",
        user: post.userId.toString(),
      });
    } catch (error: any) {
      if (error.response) {
        openaiError;
      } else {
        openaiError;
      }
    }
    const image = Buffer.from(response.data.data[0].b64_json, "base64");
    const fileType = await fromBuffer(image);
    if (
      !fileType?.mime.includes("image") &&
      !fileType?.mime.includes("video")
    ) {
      throw new AppError(
        "OpenAI type of file provided is unsupported. Our admin will look into this.",
      );
    }

    const result = await uploadMedia(
      image,
      `${post.userId}/${uuid()}.${fileType?.ext}`,
    );

    const upload = await prisma.upload.create({
      data: {
        key: result.Key,
        userId: post.userId,
        type: fileType.mime.includes("image") ? "IMAGE" : "VIDEO",
      },
    });
    //create empty botPost
    const botPost = await prisma.post.create({
      data: {
        parentPostId: post.id,
        userId: bot.id,
        content: "Here is your image generated by OpenAI.",
        uploads: {
          connect: {
            id: upload.id,
          },
        },
      },
    });

    //Calculate bot costs
    const usd = model.cost;
    await prisma.user.update({
      where: {
        id: user.id,
      },
      data: {
        tronsBalance: {
          decrement: usd,
        },
        costs: {
          create: {
            usd: usd,
            tokens: 0,
            modelId: model.id,
          },
        },
      },
    });

    return post;
  } catch (error) {
    return Promise.reject(error);
  }
};

export default generateOpenAiImageToPost;
